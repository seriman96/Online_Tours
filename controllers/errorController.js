//we come in this specific controller whenever midlleware(which is associated to route) raise n error
//this class is central for handling all error type raise as reponse for the query coming from user n it's application error handler
const AppError = require('./../utils/appError'); //central error class usage

const handleCastErrorDB = err => {
    // the path variable is basically the name of the field for which the input data is in the wrong format n value is the value of the error
    const message = `Invalid ${err.path}: ${err.value}.`;
    return new AppError(message, 400);
};

const handleDuplicateFieldsDB = err => {

    //const value = err.errmsg.match(/(["'])(?:(?=(\\?))\2.)*?\1/)[0]; //errmsg is error generated by mongoose the duplicate value here will be returned n we want the 1st elt here bcs it returned an array
    const value = err.keyValue['name'];
    console.log(value);
    const message = ` Duplicate field value: ${value}, please use another value `;
    return new AppError(message, 400);
};

const handleValidationErrorDB = err => {

    //looping over mongoose error msg 
    const errors = Object.values(err.errors).map(el => el.message); //mongoose object values means mongoose record set or data
    //console.log(errors);
    const message = ` Invalid input data. ${errors.join('. ')}`;
    return new AppError(message, 400);
};

const handleJWTError = () => new AppError('Invalid token. Please log in again!', 401); //console.log(err);//will take n error n returned a new appError, all for one single line
const handleJWTExpiredError = () => new AppError('Your token has expired! Please log in again.', 401);

const sendErrorDev = (err, req, res) =>{ //for Dev env error
    //A) API --DEVELOPMENT
    if(req.originalUrl.startsWith('/api')){ //req.originalUrl it's basically the entire url but no with host @ n it looks exactly like a route
        return res.status(err.statusCode).json({ 
            status: err.status,
            error: err, //copy of error
            message: err.message, //will return error message property
            stack: err.stack //print entire error
        });
    }

    console.error('ERROR ðŸ’¥', err);
    //B) RENDERED WEBSITE
    //rendering the error
    return res.status(err.statusCode).render('error', { // error is this template name here
        title: 'Something went wrong!',
        msg: err.message  
    });
    
    
};

const sendErrorProd = (err, req, res) =>{
    //A) API  ---PRODUCTION
    if(req.originalUrl.startsWith('/api')){
        //A) Operational, trusted error: send message to client
        if(err.isOperational){ //if some programming err or some unknowing err like err coming from third party package we don't want to send that kind of err to the client in production so in order to do that we're using isOperational
            return res.status(err.statusCode).json({ 
                status: err.status,
                message: err.message, //will return error message property
            });
        
        }
        //B) Programming or other unknow error: don't leak error detail to the client
        //1) log the error
        console.error('ERROR ðŸ’¥', err); //error() is a method specific for error
        //console.log(err.errmsg)

        //2) then send generic message
        return res.status(500).json({ 
            status: 'error',
            message: 'Something went very wrong!', //will return error message property
        }); 
        
    }
    //B) RENDERED WEBSITE
    //A) Operational, trusted error: send message to client
    if(err.isOperational){ //if some programming err or some unknowing err like err coming from third party package we don't want to send that kind of err to the client in production so in order to do that we're using isOperational
        return res.status(err.statusCode).render('error', { // error is this template name here
            title: 'Something went wrong!',
            msg: err.message  
        });
    
    }
    //B) Programming or other unknow error: don't leak error detail to the client
    //1) log the error
    console.error('ERROR ðŸ’¥', err); //error() is a method specific for error
    //console.log(err.errmsg)

    //2) then send generic message
    return res.status(err.statusCode).render('error', { // error is this template name here
        title: 'Something went wrong!',
        msg: 'Please try again later' 
    });
       
};

//express when receiving error will automatically come on error handling middleware here
module.exports = (err, req, res, next) => {
    //console.log(err.stack); //will basically show us where the error happened
  
    err.statusCode = err.statusCode || 500; //500 status cod is internal server error n this code will capture the statut code or it'll go with 500
    err.status = err.status || 'error'; //means if err.statusCode true will return err.status which is fail else means 500 will return 'error'
  
    //Distinguishing error from development n production: different msg error based on the environment means specific error for production env n specific one for development env
    if(process.env.NODE_ENV === 'development'){
        sendErrorDev(err, req, res);
    }else if(process.env.NODE_ENV === 'production'){
        //error related to mongoose 'database' handling
        let error = {...err};
        error.message = err.message; //used bcs in this env error is copied correctly
        //handling invalid id error
        if(error.name === 'CastError') error = handleCastErrorDB(error); //when we'll get a CastError it will be handle here
        
        //handle error for duplicate value(err) or field
        if(error.code === 11000) error = handleDuplicateFieldsDB(error);

        //Mongoose validation error 
        if(error.name === 'ValidationError') error = handleValidationErrorDB(error);
        //we don't have to handle th error our middleware from authController for that reason we come on central error controller here
        //json token (jwt) verification error n his handler
        if(error.name === 'JsonWebTokenError') error = handleJWTError();
        //json token Expired Error handler
        if (error.name === 'TokenExpiredError') error = handleJWTExpiredError();

        sendErrorProd(error, req, res);

    }

    
  }